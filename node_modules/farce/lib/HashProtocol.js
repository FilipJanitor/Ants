'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _off = require('dom-helpers/events/off');

var _off2 = _interopRequireDefault(_off);

var _on = require('dom-helpers/events/on');

var _on2 = _interopRequireDefault(_on);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _StateStorage = require('./StateStorage');

var _StateStorage2 = _interopRequireDefault(_StateStorage);

var _createPath = require('./utils/createPath');

var _createPath2 = _interopRequireDefault(_createPath);

var _ensureLocation = require('./utils/ensureLocation');

var _ensureLocation2 = _interopRequireDefault(_ensureLocation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HashProtocol = function () {
  function HashProtocol() {
    _classCallCheck(this, HashProtocol);

    this.stateStorage = new _StateStorage2.default(this, '@@farce');

    this._index = null;
    this._numExpectedHashChanges = 0;
  }

  HashProtocol.prototype.init = function init() {
    // TODO: Do we still need to work around the old Firefox bug here?
    var location = (0, _ensureLocation2.default)(window.location.hash.slice(1) || '/');

    var _ref = this.stateStorage.read(location, null) || {},
        _ref$index = _ref.index,
        index = _ref$index === undefined ? 0 : _ref$index,
        state = _ref.state;

    var delta = this._index != null ? index - this._index : 0;
    this._index = index;

    return _extends({
      action: 'POP'
    }, location, {
      index: index,
      delta: delta,
      state: state
    });
  };

  HashProtocol.prototype.subscribe = function subscribe(listener) {
    var _this = this;

    var onHashChange = function onHashChange() {
      // Ignore hash change events triggered by our own navigation.
      if (_this._numExpectedHashChanges > 0) {
        --_this._numExpectedHashChanges;
        return;
      }

      listener(_this.init());
    };

    (0, _on2.default)(window, 'hashchange', onHashChange);
    return function () {
      return (0, _off2.default)(window, 'hashchange', onHashChange);
    };
  };

  HashProtocol.prototype.transition = function transition(location) {
    var action = location.action,
        state = location.state;


    var push = action === 'PUSH';
    !(push || action === 'REPLACE') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Unrecognized browser protocol action ' + action + '.') : (0, _invariant2.default)(false) : void 0;

    var delta = push ? 1 : 0;
    this._index += delta;

    var path = (0, _createPath2.default)(location);

    ++this._numExpectedHashChanges;
    if (push) {
      window.location.hash = path;
    } else {
      window.location.replace('#' + path);
    }

    this.stateStorage.save(location, null, { index: this._index, state: state });

    return _extends({}, location, { index: this._index, delta: delta });
  };

  HashProtocol.prototype.go = function go(delta) {
    window.history.go(delta);
  };

  HashProtocol.prototype.createHref = function createHref(location) {
    return '#' + (0, _createPath2.default)(location);
  };

  return HashProtocol;
}();

exports.default = HashProtocol;
module.exports = exports['default'];