'use strict';

exports.__esModule = true;
exports.default = createTransitionHookMiddleware;

var _off = require('dom-helpers/events/off');

var _off2 = _interopRequireDefault(_off);

var _on = require('dom-helpers/events/on');

var _on2 = _interopRequireDefault(_on);

var _isPromise = require('is-promise');

var _isPromise2 = _interopRequireDefault(_isPromise);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _Actions = require('./Actions');

var _Actions2 = _interopRequireDefault(_Actions);

var _ActionTypes = require('./ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function runHook(hook, location, callback) {
  var result = void 0;
  try {
    result = hook(location);
  } catch (e) {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Ignoring transition hook `%s` that failed with `%s`.', hook.name, e) : void 0;

    result = null;
  }

  if (!(0, _isPromise2.default)(result)) {
    return callback(result);
  }

  result.catch(function (e) {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Ignoring transition hook `%s` that failed with `%s`.', hook.name, e) : void 0;

    return null;
  }).then(callback);

  return undefined;
}

function runHooks(hooks, location, callback) {
  if (!hooks.length) {
    return callback(true);
  }

  return runHook(hooks[0], location, function (result) {
    return result != null ? callback(result) : runHooks(hooks.slice(1), location, callback);
  });
}

function maybeConfirm(result) {
  if (typeof result === 'boolean') {
    return result;
  }

  return window.confirm(result); // eslint-disable-line no-alert
}

function runAllowTransition(hooks, location, callback) {
  return runHooks(hooks, location, function (result) {
    return callback(maybeConfirm(result));
  });
}

function createTransitionHookMiddleware(_ref) {
  var _ref$useBeforeUnload = _ref.useBeforeUnload,
      useBeforeUnload = _ref$useBeforeUnload === undefined ? false : _ref$useBeforeUnload;

  var nextStep = null;
  var hooks = [];

  function addHook(hook) {
    hooks.push(hook);

    return function () {
      hooks = hooks.filter(function (item) {
        return item !== hook;
      });
    };
  }

  var onBeforeUnload = null;

  function transitionHookMiddleware(_ref2) {
    var dispatch = _ref2.dispatch;

    return function (next) {
      return function (action) {
        var type = action.type,
            payload = action.payload;


        if (nextStep && type === _ActionTypes2.default.UPDATE_LOCATION) {
          var step = nextStep;
          nextStep = null;
          return step(next, action);
        }

        switch (type) {
          case _ActionTypes2.default.INIT:
            // Only attach this listener once.
            if (useBeforeUnload && !onBeforeUnload) {
              /* istanbul ignore next: not testable with Karma */
              onBeforeUnload = function onBeforeUnload(event) {
                var syncResult = runHooks(hooks, null, function (result) {
                  return result;
                });

                if (syncResult === true || syncResult === undefined) {
                  // An asynchronous transition hook usually means there will be
                  // a custom confirm dialog. However, we'll already be showing
                  // the before unload dialog, and there's no way to prevent the
                  // custom dialog from showing. In such cases, the application
                  // code will need to explicitly handle the null location
                  // anyway, so don't potentially show two confirmation dialogs.
                  return undefined;
                }

                var resultSafe = syncResult || '';

                event.returnValue = resultSafe; // eslint-disable-line no-param-reassign
                return resultSafe;
              };

              (0, _on2.default)(window, 'beforeunload', onBeforeUnload);
            }

            return next(action);
          case _ActionTypes2.default.TRANSITION:
            return runAllowTransition(hooks, payload, function (allowTransition) {
              if (!allowTransition) {
                return null;
              }

              // Skip the repeated transition hook check on UPDATE_LOCATION.
              nextStep = function nextStep(nextNext, nextAction) {
                return nextNext(nextAction);
              };

              return next(action);
            });
          case _ActionTypes2.default.UPDATE_LOCATION:
            {
              // No transition hooks to run.
              if (!hooks.length) {
                return next(action);
              }

              // This is the initial load. It doesn't make sense to block this
              // transition.
              if (payload.delta === 0) {
                return next(action);
              }

              // Without delta, we can't restore the location.
              if (payload.delta == null) {
                return runAllowTransition(hooks, payload, function (allowTransition) {
                  return allowTransition ? next(action) : null;
                });
              }

              var finishRunAllowTransition = function finishRunAllowTransition(result) {
                if (!maybeConfirm(result)) {
                  return null;
                }

                // Release the original UPDATE_LOCATION when the un-rewind
                // happens. We need to do so here to maintain the invariant that
                // the store location only updates after the window location.
                nextStep = function nextStep() {
                  return next(action);
                };

                dispatch(_Actions2.default.go(payload.delta));
                return undefined;
              };

              var sync = true;
              var rewindDone = false;

              var syncResult = runHooks(hooks, payload, function (result) {
                if (sync) {
                  return result;
                }

                if (!rewindDone) {
                  // The rewind hasn't finished yet. Replace the next step hook so
                  // we finish running when that happens.
                  nextStep = function nextStep() {
                    return finishRunAllowTransition(result);
                  };
                  return undefined;
                }

                return finishRunAllowTransition(result);
              });

              sync = false;

              switch (syncResult) {
                case true:
                  // The transition was synchronously allowed, so skip the rewind.
                  return next(action);
                case false:
                  // We're done as soon as the rewind finishes.
                  nextStep = function nextStep() {};
                  break;
                case undefined:
                  // Let the callback from runHooks take care of things.
                  nextStep = function nextStep() {
                    rewindDone = true;
                  };
                  break;
                default:
                  // Show the confirm dialog after the rewind.
                  nextStep = function nextStep() {
                    return finishRunAllowTransition(syncResult);
                  };
              }

              dispatch(_Actions2.default.go(-payload.delta));
              return undefined;
            }
          case _ActionTypes2.default.DISPOSE:
            if (onBeforeUnload) {
              (0, _off2.default)(window, 'beforeunload', onBeforeUnload);
              onBeforeUnload = null;
            }

            return next(action);
          default:
            return next(action);
        }
      };
    };
  }

  transitionHookMiddleware.addHook = addHook;
  return transitionHookMiddleware;
}
module.exports = exports['default'];